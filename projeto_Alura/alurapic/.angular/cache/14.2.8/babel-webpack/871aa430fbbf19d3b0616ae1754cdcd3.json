{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\n\nexport function sequenceEqual(compareTo, comparor) {\n  return source => source.lift(new SequenceEqualOperator(compareTo, comparor));\n}\nexport class SequenceEqualOperator {\n  constructor(compareTo, comparor) {\n    this.compareTo = compareTo;\n    this.comparor = comparor;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n  }\n\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nexport class SequenceEqualSubscriber extends Subscriber {\n  constructor(destination, compareTo, comparor) {\n    super(destination);\n    this.compareTo = compareTo;\n    this.comparor = comparor;\n    this._a = [];\n    this._b = [];\n    this._oneComplete = false;\n    this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n  }\n\n  _next(value) {\n    if (this._oneComplete && this._b.length === 0) {\n      this.emit(false);\n    } else {\n      this._a.push(value);\n\n      this.checkValues();\n    }\n  }\n\n  _complete() {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n  }\n\n  checkValues() {\n    const {\n      _a,\n      _b,\n      comparor\n    } = this;\n\n    while (_a.length > 0 && _b.length > 0) {\n      let a = _a.shift();\n\n      let b = _b.shift();\n\n      let areEqual = false;\n\n      if (comparor) {\n        areEqual = tryCatch(comparor)(a, b);\n\n        if (areEqual === errorObject) {\n          this.destination.error(errorObject.e);\n        }\n      } else {\n        areEqual = a === b;\n      }\n\n      if (!areEqual) {\n        this.emit(false);\n      }\n    }\n  }\n\n  emit(value) {\n    const {\n      destination\n    } = this;\n    destination.next(value);\n    destination.complete();\n  }\n\n  nextB(value) {\n    if (this._oneComplete && this._a.length === 0) {\n      this.emit(false);\n    } else {\n      this._b.push(value);\n\n      this.checkValues();\n    }\n  }\n\n}\n\nclass SequenceEqualCompareToSubscriber extends Subscriber {\n  constructor(destination, parent) {\n    super(destination);\n    this.parent = parent;\n  }\n\n  _next(value) {\n    this.parent.nextB(value);\n  }\n\n  _error(err) {\n    this.parent.error(err);\n  }\n\n  _complete() {\n    this.parent._complete();\n  }\n\n} //# sourceMappingURL=sequenceEqual.js.map","map":null,"metadata":{},"sourceType":"module"}