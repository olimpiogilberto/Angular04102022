{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\n\nexport function windowCount(windowSize, startWindowEvery = 0) {\n  return function windowCountOperatorFunction(source) {\n    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n  };\n}\n\nclass WindowCountOperator {\n  constructor(windowSize, startWindowEvery) {\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  }\n\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nclass WindowCountSubscriber extends Subscriber {\n  constructor(destination, windowSize, startWindowEvery) {\n    super(destination);\n    this.destination = destination;\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n    this.windows = [new Subject()];\n    this.count = 0;\n    destination.next(this.windows[0]);\n  }\n\n  _next(value) {\n    const startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;\n    const destination = this.destination;\n    const windowSize = this.windowSize;\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n\n    const c = this.count - windowSize + 1;\n\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      const window = new Subject();\n      windows.push(window);\n      destination.next(window);\n    }\n  }\n\n  _error(err) {\n    const windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n\n    this.destination.error(err);\n  }\n\n  _complete() {\n    const windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n\n    this.destination.complete();\n  }\n\n  _unsubscribe() {\n    this.count = 0;\n    this.windows = null;\n  }\n\n} //# sourceMappingURL=windowCount.js.map","map":null,"metadata":{},"sourceType":"module"}