{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\n\nexport function observeOn(scheduler, delay = 0) {\n  return function observeOnOperatorFunction(source) {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\nexport class ObserveOnOperator {\n  constructor(scheduler, delay = 0) {\n    this.scheduler = scheduler;\n    this.delay = delay;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  }\n\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nexport class ObserveOnSubscriber extends Subscriber {\n  constructor(destination, scheduler, delay = 0) {\n    super(destination);\n    this.scheduler = scheduler;\n    this.delay = delay;\n  }\n  /** @nocollapse */\n\n\n  static dispatch(arg) {\n    const {\n      notification,\n      destination\n    } = arg;\n    notification.observe(destination);\n    this.unsubscribe();\n  }\n\n  scheduleMessage(notification) {\n    this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n  }\n\n  _next(value) {\n    this.scheduleMessage(Notification.createNext(value));\n  }\n\n  _error(err) {\n    this.scheduleMessage(Notification.createError(err));\n  }\n\n  _complete() {\n    this.scheduleMessage(Notification.createComplete());\n  }\n\n}\nexport class ObserveOnMessage {\n  constructor(notification, destination) {\n    this.notification = notification;\n    this.destination = destination;\n  }\n\n} //# sourceMappingURL=observeOn.js.map","map":null,"metadata":{},"sourceType":"module"}