{"ast":null,"code":"import { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\n\nexport function expand(project, concurrent = Number.POSITIVE_INFINITY, scheduler = undefined) {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return source => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexport class ExpandOperator {\n  constructor(project, concurrent, scheduler) {\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  }\n\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nexport class ExpandSubscriber extends OuterSubscriber {\n  constructor(destination, project, concurrent, scheduler) {\n    super(destination);\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n    this.index = 0;\n    this.active = 0;\n    this.hasCompleted = false;\n\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  static dispatch(arg) {\n    const {\n      subscriber,\n      result,\n      value,\n      index\n    } = arg;\n    subscriber.subscribeToProjection(result, value, index);\n  }\n\n  _next(value) {\n    const destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n\n      return;\n    }\n\n    const index = this.index++;\n\n    if (this.active < this.concurrent) {\n      destination.next(value);\n      let result = tryCatch(this.project)(value, index);\n\n      if (result === errorObject) {\n        destination.error(errorObject.e);\n      } else if (!this.scheduler) {\n        this.subscribeToProjection(result, value, index);\n      } else {\n        const state = {\n          subscriber: this,\n          result,\n          value,\n          index\n        };\n        this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  subscribeToProjection(result, value, index) {\n    this.active++;\n    this.add(subscribeToResult(this, result, value, index));\n  }\n\n  _complete() {\n    this.hasCompleted = true;\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this._next(innerValue);\n  }\n\n  notifyComplete(innerSub) {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n} //# sourceMappingURL=expand.js.map","map":null,"metadata":{},"sourceType":"module"}